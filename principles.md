- [Programming Languages](#programming-languages)
  - [Abstract Syntax Trees (ASTs)](#abstract-syntax-trees-asts)
  - [Semantics](#semantics)
- [Lambda Calculus](#lambda-calculus)
  - [Referential Transparency](#referential-transparency)
- [Lists and Structural Recursion](#lists-and-structural-recursion)
- [Tail Recursion](#tail-recursion)
- [Programming with ASTs](#programming-with-asts)
  - [Racket: Quoted Expressions](#racket-quoted-expressions)
  - [Haskell: Value Constructors](#haskell-value-constructors)

---

# Programming Languages

**Syntax:** Set of rules governing the form of *allowed expressions* in a programming language.

**Grammar:** Formal description of how to *generate expressions* by substitution.

**Semantics:** Rules governing the *meaning* of programs written using the grammar.

**Non-Terminal Symbols:** Symbols that **can be substituted**, also known as *syntactic variables*.  A grammar includes a start symbol, which is a designated member from the set of non-terminal symbols from which all strings in the language may be derived by sucessive applications of production rules.

**Terminal Symbol:** Literal symbols that may appear in the outputs of the production rules of a grammar and **cannot be futher changed** by applying the rules of the grammar.

Consider a simple grammar defined by two rules:

1. The symbol $\daleth$ can become $\beth \alef$
2. The symbol $\daleth$ can become $\beth$

Here $\daleth$ is a non-terminal symbol because it has two grammar rules that can change it.  Meanwhile, $\beth$ is a terminal symbol since there is no rule that can change it into something else.

> The language defined by a grammar is precisely the set of terminal strings that can be derived by applying the rules of the grammar recusively to a source string.

An expression is **syntactically valid** $\iff$ it can be generated by the language's grammar.

## Abstract Syntax Trees (ASTs)

Because the source code can only represent a program if it is syntactically valid, parsing is always informed by the language's grammar.

**Abstract Syntax Trees (ASTs)** are a tree representation of the abstract synctactic structure of a program.  They usually all share the following properties:

1. A **leaf** is an expression that has no subexpressions (i.e. an *atomic* expression)
  - Literal values (`5, "hello"`)
  - Identifiers (`person, x`)
2. Every **internal node** represents a *compound expression*.
  - Control flow stuctures
  - Function definitions & calls
  - Arithmetic operations
3. Nodes can be categorized by the kind of expression they represent through,
  - A "tag" string
  - A `Node` class hierarchy
  - Algeraic data types
4. Node types are usually in rough correspondence to the grammar rules of the language.  We can talk about,
  - Literal value nodes
  - Function definition nodes with children for the name, parameters, and body of the function.

## Semantics

In imperative programming languages, we need to define the semantics (i.e the meaning) of individual expressions and other keywords such as `return`, `for`, etc.  In the funcional programming model, **a program is just an expression** - telling the computer to *run the program is equivalent to telling it to evaluate the expression*.

**Denotational Semantics:** An approach to formalizing the meanings a programming languages by constructing **mathematical objects (called denotations) that describe the meanings of expressions**.  For example, all the expressions below have the same denotational (or mathematical) meaning:

```py
10
3 + 7
(lambda x: x + 3)(7)
```

**Operational Semantics:** These apply meaning to expressions by focusing on execution and procedures, rather than by attaching mathematical meanings to its terms.

**Axiomatic Semantics:** Apply meaning to expressions by effect on assertions about the program state. The assertions are predicates with variables, where the variables define the state of the program (e.g. variants, invariants, etc).

# Lambda Calculus

Lambda calculus is a formal system for expressing computation based on function defintion and application, using variable binding and substitution.  In this model, **expressions are the fundamental and only units of computation**.

It consists of constructing lambda terms and performing reduction operations on them.  Thus, evaluating an expression means performing simplifications until it can no longer be simplified.

In its basic form, an expression is one of the following:
1. An **identifier** - A character or string representing a parameter, mathematical,or logical value (e.g. $x$).
2. A **function expression** $\lambda x . M$ - Function definition where $x$ becomes bound in the expression and $M$ is a lambda term (e.g. the identity function $\lambda x . x$).
3. A **function application** $f\ N$ - This expression applies the function $f$ to lambda expression $N$.

These functions have no concept of time or external state that can affect them.  The only thing we can do is susbtitute the arguments into the function, evaluate the body, and produce a single value.

```racket
(lambda (<param> ...) <body>)
```

```haskell
\ <param> ... -> <body>
```

```py
lambda <param> ... : <body>
```

In programming we say that a **mathematical pure function** is one that meets the following conditions:

1. The function's behaviour is *exactly determined by the value of its inputs*.  Pure functions must be deterministic.

> A **deterministic system** one where no randomness is involved in the development of future states of the system - thus it will always provide the same output from an initial state.

2. The function only returns a value, they have no "side effects".

## Referential Transparency

Much like in mathematics, identifier bindings in pure functional programming are immutable.  Thus, we say that an identitfier is **referentially transparent** if it can be substituted with its value in the source code without changing the meaning of the program.

# Lists and Structural Recursion

Imperative languages naturally process lists uaing loops, but pure functional programming does not permit the mutation of an index identifier to process each element one at a time.  So we define lists recursively as:
1. The empty list is a list.
2. If `x` is a value and `lst` is a list, we can create a new list by combining `x` with the elements of `lst`.

The grammar for creating a list in **Racket** looks like this:

```
<list> =  'null'| '(' 'cons' <expr> <list> ')'
```

While the grammar for creating a list in **Haskell** is:

```
<list> = '[]' | <expr> ':' <list>
```

This recursive definition of lists tells us, not only about their representation, but also how to operate on them (Hint: It's recursive!).  We want to operate on the first, element of the list then recusively operate on the rest.

# Tail Recursion

Tail recursion is a technique to optimize recursive functions by **making the recursive call the last thing you do**, i.e. the recursion is the *tail call*.  [This](https://www.youtube.com/watch?v=_JtPhF8MshA) is a great video that explains why tail recursion is so much more efficient.

> A **tail call** is a **subroutine call performed as the final action of a procedure**.  When the subroutine is identical to the procedure, we refer to the subroutine as tail recursive.

Haskell and Racket take advantage of tail recursion: when it calls a function that is in tail call position (this is detected by the compiler), it first **removes the calling function's stack frame, and this results in constant stack height**.

```rkt
; traditional recursive definition
(define (sum lst)
    (if (empty? lst)
    0
    (+ (first lst) (sum (rest lst)))))

; tail call recursive definition
(define (sum-tail lst)
    (sum-helper lst 0))

(define (sum-helper lst agg)
    (if (empty? lst)
    agg
    (sum-helper (rest lst) (+ agg (first lst)))))
```

The evaluation of `(sum-tail '(1 2 3 4))` produces the function calls `(sum-helper '(1 2 3 4) 0)`, `(sum-helper '(2 3 4) 1)`, `(sum-helper '(3 4) 3)`, etc.  Since Racket performs tail call elimination, each of these function calls replaces the stack frame for the one before it. So the sequence,

```rkt
(sum-helper '(1 2 3 4) 0)
(sum-helper '(2 3 4) 1)
(sum-helper '(3 4) 3)
(sum-helper '(4) 6)
(sum-helper '() 10)
```

can really be viewed, not as five function calls, but as an iterative process that executes the function body and updates the variables `lst` and `agg` with every iteration.

# Programming with ASTs

We can generalize the *list* data structure into the *tree* data structure, where **the recursive part of the structure contains an arbitrary number of subcomponents** rather than just one.

## Racket: Quoted Expressions

Since Racket is a Lisp descendant, **the parenthesization of source code immediately creates a nested list structure**, i.e. a tree.  We call this *quoting an expression*.

```rkt
; a regular racket expression 
(+ 1 2)
; 3

; a list of three elements
(first '(+ 1 2))
; '+

; this is a nested list
'((+ 1 2) (* 4 5))
```

Fomally, here are the types of values that make up the tree strucutre in a Racket datum:

1. **Literal to literal** - Quoted literals (e.g. ints, bools, strings) represent the same values in the tree that they do in the source code.

```rkt
(equal? '#t #t)
; #t

(equal? '"hello" "hello")
; #t
```

2. **Keyword to symbol** -  Quoted identifiers or keywords become symbols in the tree and can be used for pattern-matching.

3. Quoted compound expressions become lists, in which each element is the quoted version of the corresponding subexpression.

Here is an example of a function that takes in a datum and returns the number of times the identifier `+` appears in the datum:

```rkt
(define/match (num-plus datum)
    [((list expr ...)) (apply + (map num-plus expr))]
    [('+) 1]
    [(_) 0])
```

## Haskell: Value Constructors

Since Haskell lists must be homogenous, we cannot store a list with nested lists, symbols and literals all mixed in.

However, its type system does allow us to to declare and pattern match on a type with multiple constructors.

```hs
data Expr = 
    -- An integer literal
    NumLiteral Int 
    -- An identifier
    | Identifier String
    -- A function call where
        -- Expr is the function being called
        -- [Expr contains the arguments]
    | Call Expr [Expr] -- A function call
```

The main point is that `NumLiteral`,`Identifier`, and `Call` are *value constructors* that take in a type and return a value of type `Expr`.  Notice how the structure is in line with the [definition](#abstract-syntax-trees-asts) of an AST.

Here is the implementation in Haskell of the `numPlus` function we wrote above in Racket:

```hs
numPlus :: Num a => Expr -> a
numPlus (Call f args) = numPlus f + sum (map numPlus args)
numPlus (Identifier "+") = 1
numPlus (Identifier _) = 0
numPlus (NumLiteral _) = 0
```





