- [Programming Languages](#programming-languages)
  - [Abstract Syntax Trees (ASTs)](#abstract-syntax-trees-asts)
  - [Semantics](#semantics)
- [Lambda Calculus](#lambda-calculus)
  - [Referential Transparency](#referential-transparency)
- [Lists and Structural Recursion](#lists-and-structural-recursion)

---

# Programming Languages

**Syntax:** Set of rules governing the form of *allowed expressions* in a programming language.

**Grammar:** Formal description of how to *generate expressions* by substitution.

**Semantics:** Rules governing the *meaning* of programs written using the grammar.

**Non-Terminal Symbols:** Symbols that **can be substituted**, also known as *syntactic variables*.  A grammar includes a start symbol, which is a designated member from the set of non-terminal symbols from which all strings in the language may be derived by sucessive applications of production rules.

**Terminal Symbol:** Literal symbols that may appear in the outputs of the production rules of a grammar and **cannot be futher changed** by applying the rules of the grammar.

Consider a simple grammar defined by two rules:

1. The symbol $\daleth$ can become $\beth \alef$
2. The symbol $\daleth$ can become $\beth$

Here $\daleth$ is a non-terminal symbol because it has two grammar rules that can change it.  Meanwhile, $\beth$ is a terminal symbol since there is no rule that can change it into something else.

> The language defined by a grammar is precisely the set of terminal strings that can be derived by applying the rules of the grammar recusively to a source string.

An expression is **syntactically valid** $\iff$ it can be generated by the language's grammar.

## Abstract Syntax Trees (ASTs)

Because the source code can only represent a program if it is syntactically valid, parsing is always informed by the language's grammar.

**Abstract Syntax Trees (ASTs)** are a tree representation of the abstract synctactic structure of a program.  They usually all share the following properties:

1. A **leaf** is an expression that has no subexpressions (i.e. an *atomic* expression)
  - Literal values (`5, "hello"`)
  - Identifiers (`person, x`)
2. Every **internal node** represents a *compound expression*.
  - Control flow stuctures
  - Function definitions & calls
  - Arithmetic operations
3. Nodes can be categorized by the kind of expression they represent through,
  - A "tag" string
  - A `Node` class hierarchy
  - Algeraic data types
4. Node types are usually in rough correspondence to the grammar rules of the language.  We can talk about,
  - Literal value nodes
  - Function definition nodes with children for the name, parameters, and body of the function.

## Semantics

In imperative programming languages, we need to define the semantics (i.e the meaning) of individual expressions and other keywords such as `return`, `for`, etc.  In the funcional programming model, **a program is just an expression** - telling the computer to *run the program is equivalent to telling it to evaluate the expression*.

**Denotational Semantics:** An approach to formalizing the meanings a programming languages by constructing **mathematical objects (called denotations) that describe the meanings of expressions**.  For example, all the expressions below have the same denotational (or mathematical) meaning:

```py
10
3 + 7
(lambda x: x + 3)(7)
```

**Operational Semantics:** These apply meaning to expressions by focusing on execution and procedures, rather than by attaching mathematical meanings to its terms.

**Axiomatic Semantics:** Apply meaning to expressions by effect on assertions about the program state. The assertions are predicates with variables, where the variables define the state of the program (e.g. variants, invariants, etc).

# Lambda Calculus

Lambda calculus is a formal system for expressing computation based on function defintion and application, using variable binding and substitution.  In this model, **expressions are the fundamental and only units of computation**.

It consists of constructing lambda terms and performing reduction operations on them.  Thus, evaluating an expression means performing simplifications until it can no longer be simplified.

In its basic form, an expression is one of the following:
1. An **identifier** - A character or string representing a parameter, mathematica,or logical value (e.g. $x$).
2. A **function expression** $\lambda x . M$ - Function definition where $x$ becomes bound in the expression and $M$ is a lambda term (e.g. the identity function $\lambda x . x$).
3. A **function application** $f\ N$ - This expression applies the function $f$ to lambda expression $N$.

These functions have no concept of time or external state that can affect them.  The only thing we can do is susbtitute the arguments into the function, evaluate the body, and produce a single value.

```racket
(lambda (<param> ...) <body>)
```

```haskell
\ <param> ... -> <body>
```

```py
lambda <param> ... : <body>
```

In programming we say that a **mathematical pure function** is one that meets the following conditions:

1. The function's behaviour is *exactly determined by the value of its inputs*.  Pure functions must be deterministic.

> A **deterministic system** one where no randomness is involved in the development of future states of the system - thus it will always provide the same output from an initial state.

2. The function only returns a value, they have no "side effects".

## Referential Transparency

Much like in mathematics, identifier bindings in pure functional programming are immutable.  Thus, we say that an identitfier is **referentially transparent** if it can be substituted with its value in the source code without changing the meaning of the program.

# Lists and Structural Recursion

Imperative languages naturally process lists uaing loops, but pure functional programming does not permit the mutation of an index identifier to process each element one at a time.  So we define lists recursively as:
1. The empty list is a list.
2. If `x` is a value and `lst` is a list, we can create a new list by combining `x` with the elements of `lst`.

The grammar for creating a list in **Racket** looks like this:

```
<list> =  'null'| '(' 'cons' <expr> <list> ')'
```

While the grammar for creating a list in **Haskell** is:

```
<list> = '[]' | <expr> ':' <list>
```

This recursive definition of lists tells us, not only about their representation, but also how to operate on them (Hint: It's recursive!)